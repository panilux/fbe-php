#!/usr/bin/env php
<?php
/**
 * Fast Binary Encoding compiler for PHP
 * 
 * Generates PHP code from .fbe schema files
 * HERSEY DAHA IYI BIR PANILUX ICIN! ðŸš€
 */

declare(strict_types=1);

if ($argc < 3) {
    fwrite(STDERR, "Usage: fbec <input.fbe> <output_dir>\n");
    exit(1);
}

$inputFile = $argv[1];
$outputDir = $argv[2];

try {
    $generator = new FBEGenerator();
    $generator->generate($inputFile, $outputDir);
    echo "âœ“ Code generation successful!\n";
} catch (Exception $e) {
    fwrite(STDERR, "âœ— Error: {$e->getMessage()}\n");
    exit(1);
}

class FBEGenerator
{
    private array $enums = [];
    private array $flags = [];
    private array $structs = [];
    private string $package = '';

    public function generate(string $inputFile, string $outputDir): void
    {
        $content = file_get_contents($inputFile);
        if ($content === false) {
            throw new Exception("Failed to read $inputFile");
        }

        if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true)) {
            throw new Exception("Failed to create output directory");
        }

        $this->parse($content);
        $this->generateCode($outputDir);

        echo sprintf("Generated %d enums, %d flags, %d structs\n",
            count($this->enums), count($this->flags), count($this->structs));
    }

    private function parse(string $content): void
    {
        $this->parsePackage($content);
        $this->parseEnums($content);
        $this->parseFlags($content);
        $this->parseStructs($content);
    }

    private function parsePackage(string $content): void
    {
        if (preg_match('/package\s+(\w+)/', $content, $match)) {
            $this->package = $match[1];
        }
    }

    private function parseEnums(string $content): void
    {
        preg_match_all('/enum\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);
        
        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            $index = 0;
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                    $index++;
                } else {
                    $key = trim(rtrim($line, ';'));
                    if (!empty($key)) {
                        $values[$key] = (string)$index;
                        $index++;
                    }
                }
            }

            $this->enums[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseFlags(string $content): void
    {
        preg_match_all('/flags\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);
        
        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                }
            }

            $this->flags[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseStructs(string $content): void
    {
        // Match: struct Name(id)? (: BaseStruct)? { fields }
        preg_match_all('/struct\s+(\w+)(?:\([^)]+\))?(?:\s*:\s*([\w.]+))?\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);
        
        foreach ($matches as $match) {
            $name = $match[1];
            $baseStruct = !empty($match[2]) ? $match[2] : null;
            $body = $match[3];

            $fields = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                // Check for [key] attribute
                $isKey = false;
                if (str_starts_with($line, '[key]')) {
                    $isKey = true;
                    $line = trim(substr($line, 5)); // Remove [key] prefix
                }

                // Match: type? []? name (= defaultValue)?;
                if (preg_match('/(\w+)(\?)?(\[\])?\s+(\w+)(?:\s*=\s*([^;]+))?/', $line, $fieldMatch)) {
                    $defaultValue = isset($fieldMatch[5]) ? trim($fieldMatch[5]) : null;
                    $fields[] = [
                        'fbeType' => $fieldMatch[1],
                        'isOptional' => !empty($fieldMatch[2]),
                        'isArray' => !empty($fieldMatch[3]),
                        'name' => $fieldMatch[4],
                        'isKey' => $isKey,
                        'defaultValue' => $defaultValue,
                    ];
                }
            }

            $this->structs[] = compact('name', 'baseStruct', 'fields');
        }
    }

    private function generateCode(string $outputDir): void
    {
        foreach ($this->enums as $enum) {
            $this->generateEnum($enum, $outputDir);
        }

        foreach ($this->flags as $flags) {
            $this->generateFlags($flags, $outputDir);
        }

        foreach ($this->structs as $struct) {
            $this->generateStruct($struct, $outputDir);
        }
    }

    private function generateEnum(array $enum, string $outputDir): void
    {
        $name = $enum['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "enum $name: int\n{\n";
        
        foreach ($enum['values'] as $key => $val) {
            $code .= "    case " . ucfirst($key) . " = $val;\n";
        }
        
        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateFlags(array $flags, string $outputDir): void
    {
        $name = $flags['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "class $name\n{\n";
        
        foreach ($flags['values'] as $key => $val) {
            $constName = strtoupper(preg_replace('/([a-z])([A-Z])/', '$1_$2', $key));
            $code .= "    public const " . strtoupper($key) . " = $val;\n";
        }
        
        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateStruct(array $struct, string $outputDir): void
    {
        $name = $struct['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "use FBE\\WriteBuffer;\n";
        $code .= "use FBE\\ReadBuffer;\n\n";
        
        // Add extends clause if base struct exists
        $extendsClause = '';
        if (!empty($struct['baseStruct'])) {
            $baseClass = $this->resolveBaseClass($struct['baseStruct']);
            $extendsClause = " extends $baseClass";
        }
        
        $code .= "class $name$extendsClause\n{\n";
        
        foreach ($struct['fields'] as $field) {
            $phpType = $this->mapFieldType($field);
            $code .= "    public $phpType \${$field['name']};\n";
        }
        
        $code .= "\n    public function __construct()\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        parent::__construct();\n";
        }
        foreach ($struct['fields'] as $field) {
            $default = $this->getDefaultValue($field);
            $code .= "        \$this->{$field['name']} = $default;\n";
        }
        $code .= "    }\n\n";

        // Serialize method
        $code .= "    public function serialize(WriteBuffer \$buffer): int\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        \$offset = parent::serialize(\$buffer);\n";
        } else {
            $code .= "        \$offset = 0;\n";
        }
        foreach ($struct['fields'] as $field) {
            $code .= $this->generateSerializeField($field);
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";

        // Deserialize method
        $code .= "    public static function deserialize(ReadBuffer \$buffer): self\n    {\n";
        $code .= "        \$obj = new self();\n";
        $code .= "        \$offset = \$obj->deserializeFields(\$buffer);\n";
        $code .= "        return \$obj;\n";
        $code .= "    }\n\n";
        
        // DeserializeFields method (protected, for inheritance)
        $code .= "    protected function deserializeFields(ReadBuffer \$buffer): int\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        \$offset = parent::deserializeFields(\$buffer);\n";
        } else {
            $code .= "        \$offset = 0;\n";
        }
        foreach ($struct['fields'] as $field) {
            $code .= $this->generateDeserializeField($field, true);  // Use $this instead of $obj
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";
        
        // Add getKey() method if struct has key fields
        $keyFields = array_filter($struct['fields'], fn($f) => $f['isKey'] ?? false);
        if (!empty($keyFields)) {
            $code .= "    /**\n";
            $code .= "     * Get key fields for hashing and equality\n";
            $code .= "     */\n";
            $code .= "    public function getKey(): array\n    {\n";
            $code .= "        return [";
            $keyNames = array_map(fn($f) => "\$this->{$f['name']}", $keyFields);
            $code .= implode(", ", $keyNames);
            $code .= "];\n";
            $code .= "    }\n\n";
            
            // Add equals() method
            $code .= "    /**\n";
            $code .= "     * Check equality based on key fields\n";
            $code .= "     */\n";
            $code .= "    public function equals(self \$other): bool\n    {\n";
            foreach ($keyFields as $field) {
                $code .= "        if (\$this->{$field['name']} !== \$other->{$field['name']}) {\n";
                $code .= "            return false;\n";
                $code .= "        }\n";
            }
            $code .= "        return true;\n";
            $code .= "    }\n";
        }
        
        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateSerializeField(array $field): string
    {
        $writeMethod = $this->getWriteMethod($field['fbeType']);
        $size = $this->getTypeSize($field['fbeType']);
        $isPrimitive = in_array($field['fbeType'], ['bool', 'byte', 'int8', 'int16', 'int32', 'int64', 
                                                      'uint8', 'uint16', 'uint32', 'uint64', 'float', 'double', 'string']);
        
        if ($field['fbeType'] === 'string') {
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']});\n" .
                   "        \$offset += 4 + strlen(\$this->{$field['name']});\n";
        } elseif (!$isPrimitive) {
            // Enum - cast to int
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']}->value);\n" .
                   "        \$offset += $size;\n";
        } else {
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']});\n" .
                   "        \$offset += $size;\n";
        }
    }

    private function generateDeserializeField(array $field, bool $useThis = false): string
    {
        $readMethod = $this->getReadMethod($field['fbeType']);
        $size = $this->getTypeSize($field['fbeType']);
        $isPrimitive = in_array($field['fbeType'], ['bool', 'byte', 'int8', 'int16', 'int32', 'int64', 
                                                      'uint8', 'uint16', 'uint32', 'uint64', 'float', 'double', 'string']);
        
        $var = $useThis ? '$this' : '$obj';
        
        if ($field['fbeType'] === 'string') {
            return "        {$var}->{$field['name']} = \$buffer->{$readMethod}(\$offset);\n" .
                   "        \$offset += 4 + strlen({$var}->{$field['name']});\n";
        } elseif (!$isPrimitive) {
            // Enum - from int to enum
            return "        {$var}->{$field['name']} = {$field['fbeType']}::from(\$buffer->{$readMethod}(\$offset));\n" .
                   "        \$offset += $size;\n";
        } else {
            return "        {$var}->{$field['name']} = \$buffer->{$readMethod}(\$offset);\n" .
                   "        \$offset += $size;\n";
        }
    }

    private function getWriteMethod(string $fbeType): string
    {
        return match ($fbeType) {
            'bool' => 'writeBool',
            'byte', 'int8' => 'writeInt8',
            'uint8' => 'writeUInt8',
            'int16' => 'writeInt16',
            'uint16' => 'writeUInt16',
            'int32' => 'writeInt32',
            'uint32' => 'writeUInt32',
            'int64' => 'writeInt64',
            'uint64' => 'writeUInt64',
            'float' => 'writeFloat',
            'double' => 'writeDouble',
            'string' => 'writeString',
            default => 'writeInt32',
        };
    }

    private function getReadMethod(string $fbeType): string
    {
        return match ($fbeType) {
            'bool' => 'readBool',
            'byte', 'int8' => 'readInt8',
            'uint8' => 'readUInt8',
            'int16' => 'readInt16',
            'uint16' => 'readUInt16',
            'int32' => 'readInt32',
            'uint32' => 'readUInt32',
            'int64' => 'readInt64',
            'uint64' => 'readUInt64',
            'float' => 'readFloat',
            'double' => 'readDouble',
            'string' => 'readString',
            default => 'readInt32',
        };
    }

    private function getTypeSize(string $fbeType): int
    {
        return match ($fbeType) {
            'bool', 'byte', 'int8', 'uint8' => 1,
            'int16', 'uint16' => 2,
            'int32', 'uint32', 'float' => 4,
            'int64', 'uint64', 'double' => 8,
            default => 4,
        };
    }

    private function mapFieldType(array $field): string
    {
        $baseType = match ($field['fbeType']) {
            'bool' => 'bool',
            'byte', 'int8', 'int16', 'int32', 'int64' => 'int',
            'uint8', 'uint16', 'uint32', 'uint64' => 'int',
            'float', 'double' => 'float',
            'string' => 'string',
            default => $field['fbeType'],
        };

        if ($field['isArray']) {
            return $field['isOptional'] ? '?array' : 'array';
        } elseif ($field['isOptional']) {
            return "?$baseType";
        }
        
        return $baseType;
    }

    private function getDefaultValue(array $field): string
    {
        // Use schema default if provided
        if (!empty($field['defaultValue'])) {
            return $this->convertDefaultValue($field['defaultValue'], $field['fbeType']);
        }
        
        if ($field['isArray']) {
            return '[]';
        }

        return match ($field['fbeType']) {
            'bool' => 'false',
            'byte', 'int8', 'int16', 'int32', 'int64' => '0',
            'uint8', 'uint16', 'uint32', 'uint64' => '0',
            'float', 'double' => '0.0',
            'string' => "''",
            default => $field['fbeType'] . '::cases()[0]',  // First enum case
        };
    }
    
    private function convertDefaultValue(string $value, string $fbeType): string
    {
        // Handle special keywords
        if ($value === 'null') {
            return 'null';
        }
        if ($value === 'true' || $value === 'false') {
            return $value;
        }
        
        // Handle string literals
        if (str_starts_with($value, '"') || str_starts_with($value, "'")) {
            return $value;
        }
        
        // Handle numeric values
        if (is_numeric($value)) {
            // Add .0 for float/double if integer
            if (($fbeType === 'float' || $fbeType === 'double') && !str_contains($value, '.')) {
                return $value . '.0';
            }
            return $value;
        }
        
        // Handle enum/flag values (e.g., OrderSide.buy)
        if (str_contains($value, '.')) {
            return $value;
        }
        
        // Default: return as-is
        return $value;
    }

    private function resolveBaseClass(string $baseStruct): string
    {
        // Handle cross-package references (e.g., proto.Balance)
        if (str_contains($baseStruct, '.')) {
            $parts = explode('.', $baseStruct);
            return end($parts);  // For now, just use the class name
        }
        return $baseStruct;
    }
}

