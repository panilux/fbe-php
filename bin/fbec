#!/usr/bin/env php
<?php
/**
 * Fast Binary Encoding compiler for PHP
 *
 * Generates PHP code from .fbe schema files
 */

declare(strict_types=1);

if ($argc < 3) {
    fwrite(STDERR, "Usage: fbec <input.fbe> <output_dir>\n");
    exit(1);
}

$inputFile = $argv[1];
$outputDir = $argv[2];

try {
    $generator = new FBEGenerator();
    $generator->generate($inputFile, $outputDir);
    echo "✓ Code generation successful!\n";
} catch (Exception $e) {
    fwrite(STDERR, "✗ Error: {$e->getMessage()}\n");
    exit(1);
}

class FBEGenerator
{
    private array $enums = [];
    private array $flags = [];
    private array $structs = [];
    private string $package = '';

    public function generate(string $inputFile, string $outputDir): void
    {
        $content = file_get_contents($inputFile);
        if ($content === false) {
            throw new Exception("Failed to read $inputFile");
        }

        if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true)) {
            throw new Exception("Failed to create output directory");
        }

        $this->parse($content);
        $this->generateCode($outputDir);

        echo sprintf("Generated %d enums, %d flags, %d structs\n",
            count($this->enums), count($this->flags), count($this->structs));
    }

    private function parse(string $content): void
    {
        $this->parsePackage($content);
        $this->parseEnums($content);
        $this->parseFlags($content);
        $this->parseStructs($content);
    }

    private function parsePackage(string $content): void
    {
        if (preg_match('/package\s+(\w+)/', $content, $match)) {
            $this->package = $match[1];
        }
    }

    private function parseEnums(string $content): void
    {
        preg_match_all('/enum\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            $index = 0;
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                    $index++;
                } else {
                    $key = trim(rtrim($line, ';'));
                    if (!empty($key)) {
                        $values[$key] = (string)$index;
                        $index++;
                    }
                }
            }

            $this->enums[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseFlags(string $content): void
    {
        preg_match_all('/flags\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                }
            }

            $this->flags[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseStructs(string $content): void
    {
        // Match: struct Name(id)? (: BaseStruct)? { fields }
        preg_match_all('/struct\s+(\w+)(?:\([^)]+\))?(?:\s*:\s*([\w.]+))?\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $baseStruct = !empty($match[2]) ? $match[2] : null;
            $body = $match[3];

            $fields = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                // Check for [key] attribute
                $isKey = false;
                if (str_starts_with($line, '[key]')) {
                    $isKey = true;
                    $line = trim(substr($line, 5)); // Remove [key] prefix
                }

                // Match: type? []? name (= defaultValue)?;
                if (preg_match('/(\w+)(\?)?(\[\])?\s+(\w+)(?:\s*=\s*([^;]+))?/', $line, $fieldMatch)) {
                    $defaultValue = isset($fieldMatch[5]) ? trim($fieldMatch[5]) : null;
                    $fields[] = [
                        'fbeType' => $fieldMatch[1],
                        'isOptional' => !empty($fieldMatch[2]),
                        'isArray' => !empty($fieldMatch[3]),
                        'name' => $fieldMatch[4],
                        'isKey' => $isKey,
                        'defaultValue' => $defaultValue,
                    ];
                }
            }

            $this->structs[] = compact('name', 'baseStruct', 'fields');
        }
    }

    private function generateCode(string $outputDir): void
    {
        foreach ($this->enums as $enum) {
            $this->generateEnum($enum, $outputDir);
        }

        foreach ($this->flags as $flags) {
            $this->generateFlags($flags, $outputDir);
        }

        foreach ($this->structs as $struct) {
            $this->generateStruct($struct, $outputDir);
            $this->generateModel($struct, $outputDir);
            $this->generateFinalModel($struct, $outputDir);
        }
    }

    private function generateEnum(array $enum, string $outputDir): void
    {
        $name = $enum['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "enum $name: int\n{\n";

        foreach ($enum['values'] as $key => $val) {
            $code .= "    case " . ucfirst($key) . " = $val;\n";
        }

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateFlags(array $flags, string $outputDir): void
    {
        $name = $flags['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "class $name\n{\n";

        foreach ($flags['values'] as $key => $val) {
            $constName = strtoupper(preg_replace('/([a-z])([A-Z])/', '$1_$2', $key));
            $code .= "    public const " . strtoupper($key) . " = $val;\n";
        }

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateStruct(array $struct, string $outputDir): void
    {
        $name = $struct['name'];
        $fileName = "$outputDir/$name.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "use FBE\\WriteBuffer;\n";
        $code .= "use FBE\\ReadBuffer;\n\n";

        // Add extends clause if base struct exists
        $extendsClause = '';
        if (!empty($struct['baseStruct'])) {
            $baseClass = $this->resolveBaseClass($struct['baseStruct']);
            $extendsClause = " extends $baseClass";
        }

        $code .= "class $name$extendsClause\n{\n";

        foreach ($struct['fields'] as $field) {
            $phpType = $this->mapFieldType($field);
            $code .= "    public $phpType \${$field['name']};\n";
        }

        $code .= "\n    public function __construct()\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        parent::__construct();\n";
        }
        foreach ($struct['fields'] as $field) {
            $default = $this->getDefaultValue($field);
            $code .= "        \$this->{$field['name']} = $default;\n";
        }
        $code .= "    }\n\n";

        // Serialize method
        $code .= "    public function serialize(WriteBuffer \$buffer): int\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        \$offset = parent::serialize(\$buffer);\n";
        } else {
            $code .= "        \$offset = 0;\n";
        }
        foreach ($struct['fields'] as $field) {
            $code .= $this->generateSerializeField($field);
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";

        // Deserialize method
        $code .= "    public static function deserialize(ReadBuffer \$buffer): self\n    {\n";
        $code .= "        \$obj = new self();\n";
        $code .= "        \$offset = \$obj->deserializeFields(\$buffer);\n";
        $code .= "        return \$obj;\n";
        $code .= "    }\n\n";

        // DeserializeFields method (protected, for inheritance)
        $code .= "    protected function deserializeFields(ReadBuffer \$buffer): int\n    {\n";
        if (!empty($struct['baseStruct'])) {
            $code .= "        \$offset = parent::deserializeFields(\$buffer);\n";
        } else {
            $code .= "        \$offset = 0;\n";
        }
        foreach ($struct['fields'] as $field) {
            $code .= $this->generateDeserializeField($field, true);  // Use $this instead of $obj
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";

        // Add JSON serialization methods
        $code .= "    /**\n";
        $code .= "     * Convert struct to JSON string\n";
        $code .= "     */\n";
        $code .= "    public function toJson(): string\n    {\n";
        $code .= "        return json_encode(\$this, JSON_THROW_ON_ERROR);\n";
        $code .= "    }\n\n";

        $code .= "    /**\n";
        $code .= "     * Create struct from JSON string\n";
        $code .= "     */\n";
        $code .= "    public static function fromJson(string \$json): self\n    {\n";
        $code .= "        \$data = json_decode(\$json, true, 512, JSON_THROW_ON_ERROR);\n";
        $code .= "        \$obj = new self();\n";
        foreach ($struct['fields'] as $field) {
            $code .= "        \$obj->{$field['name']} = \$data['{$field['name']}'] ?? \$obj->{$field['name']};\n";
        }
        $code .= "        return \$obj;\n";
        $code .= "    }\n\n";

        // Add __toString for logging
        $code .= "    /**\n";
        $code .= "     * Convert struct to string for logging\n";
        $code .= "     */\n";
        $code .= "    public function __toString(): string\n    {\n";
        $code .= "        return '{$name}(' . ";
        $fieldStrings = [];
        foreach ($struct['fields'] as $field) {
            $fieldStrings[] = "'{$field['name']}=' . var_export(\$this->{$field['name']}, true)";
        }
        $code .= implode(" . ', ' . ", $fieldStrings);
        $code .= " . ')';";  
        $code .= "\n    }\n\n";

        // Add getKey() method if struct has key fields
        $keyFields = array_filter($struct['fields'], fn($f) => $f['isKey'] ?? false);
        if (!empty($keyFields)) {
            $code .= "    /**\n";
            $code .= "     * Get key fields for hashing and equality\n";
            $code .= "     */\n";
            $code .= "    public function getKey(): array\n    {\n";
            $code .= "        return [";
            $keyNames = array_map(fn($f) => "\$this->{$f['name']}", $keyFields);
            $code .= implode(", ", $keyNames);
            $code .= "];\n";
            $code .= "    }\n\n";

            // Add equals() method
            $code .= "    /**\n";
            $code .= "     * Check equality based on key fields\n";
            $code .= "     */\n";
            $code .= "    public function equals(self \$other): bool\n    {\n";
            foreach ($keyFields as $field) {
                $code .= "        if (\$this->{$field['name']} !== \$other->{$field['name']}) {\n";
                $code .= "            return false;\n";
                $code .= "        }\n";
            }
            $code .= "        return true;\n";
            $code .= "    }\n";
        }

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateSerializeField(array $field): string
    {
        $writeMethod = $this->getWriteMethod($field['fbeType']);
        $size = $this->getTypeSize($field['fbeType']);
        $isPrimitive = in_array($field['fbeType'], ['bool', 'byte', 'int8', 'int16', 'int32', 'int64',
                                                      'uint8', 'uint16', 'uint32', 'uint64', 'float', 'double', 'string']);

        if ($field['fbeType'] === 'string') {
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']});\n" .
                   "        \$offset += 4 + strlen(\$this->{$field['name']});\n";
        } elseif (!$isPrimitive) {
            // Enum - cast to int
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']}->value);\n" .
                   "        \$offset += $size;\n";
        } else {
            return "        \$buffer->{$writeMethod}(\$offset, \$this->{$field['name']});\n" .
                   "        \$offset += $size;\n";
        }
    }

    private function generateDeserializeField(array $field, bool $useThis = false): string
    {
        $readMethod = $this->getReadMethod($field['fbeType']);
        $size = $this->getTypeSize($field['fbeType']);
        $isPrimitive = in_array($field['fbeType'], ['bool', 'byte', 'int8', 'int16', 'int32', 'int64',
                                                      'uint8', 'uint16', 'uint32', 'uint64', 'float', 'double', 'string']);

        $var = $useThis ? '$this' : '$obj';

        if ($field['fbeType'] === 'string') {
            return "        {$var}->{$field['name']} = \$buffer->{$readMethod}(\$offset);\n" .
                   "        \$offset += 4 + strlen({$var}->{$field['name']});\n";
        } elseif (!$isPrimitive) {
            // Enum - from int to enum
            return "        {$var}->{$field['name']} = {$field['fbeType']}::from(\$buffer->{$readMethod}(\$offset));\n" .
                   "        \$offset += $size;\n";
        } else {
            return "        {$var}->{$field['name']} = \$buffer->{$readMethod}(\$offset);\n" .
                   "        \$offset += $size;\n";
        }
    }

    private function getWriteMethod(string $fbeType): string
    {
        return match ($fbeType) {
            'bool' => 'writeBool',
            'byte', 'int8' => 'writeInt8',
            'uint8' => 'writeUInt8',
            'int16' => 'writeInt16',
            'uint16' => 'writeUInt16',
            'int32' => 'writeInt32',
            'uint32' => 'writeUInt32',
            'int64' => 'writeInt64',
            'uint64' => 'writeUInt64',
            'float' => 'writeFloat',
            'double' => 'writeDouble',
            'string' => 'writeString',
            default => 'writeInt32',
        };
    }

    private function getReadMethod(string $fbeType): string
    {
        return match ($fbeType) {
            'bool' => 'readBool',
            'byte', 'int8' => 'readInt8',
            'uint8' => 'readUInt8',
            'int16' => 'readInt16',
            'uint16' => 'readUInt16',
            'int32' => 'readInt32',
            'uint32' => 'readUInt32',
            'int64' => 'readInt64',
            'uint64' => 'readUInt64',
            'float' => 'readFloat',
            'double' => 'readDouble',
            'string' => 'readString',
            default => 'readInt32',
        };
    }

    private function getTypeSize(string $fbeType): int
    {
        return match ($fbeType) {
            'bool', 'byte', 'int8', 'uint8' => 1,
            'int16', 'uint16' => 2,
            'int32', 'uint32', 'float' => 4,
            'int64', 'uint64', 'double' => 8,
            default => 4,
        };
    }

    private function mapFieldType(array $field): string
    {
        $baseType = match ($field['fbeType']) {
            'bool' => 'bool',
            'byte', 'int8', 'int16', 'int32', 'int64' => 'int',
            'uint8', 'uint16', 'uint32', 'uint64' => 'int',
            'float', 'double' => 'float',
            'string' => 'string',
            default => $field['fbeType'],
        };

        if ($field['isArray']) {
            return $field['isOptional'] ? '?array' : 'array';
        } elseif ($field['isOptional']) {
            return "?$baseType";
        }

        return $baseType;
    }

    private function getDefaultValue(array $field): string
    {
        // Use schema default if provided
        if (!empty($field['defaultValue'])) {
            return $this->convertDefaultValue($field['defaultValue'], $field['fbeType']);
        }

        if ($field['isArray']) {
            return '[]';
        }

        return match ($field['fbeType']) {
            'bool' => 'false',
            'byte', 'int8', 'int16', 'int32', 'int64' => '0',
            'uint8', 'uint16', 'uint32', 'uint64' => '0',
            'float', 'double' => '0.0',
            'string' => "''",
            default => $field['fbeType'] . '::cases()[0]',  // First enum case
        };
    }

    private function convertDefaultValue(string $value, string $fbeType): string
    {
        // Handle special keywords
        if ($value === 'null') {
            return 'null';
        }
        if ($value === 'true' || $value === 'false') {
            return $value;
        }

        // Handle string literals
        if (str_starts_with($value, '"') || str_starts_with($value, "'")) {
            return $value;
        }

        // Handle numeric values
        if (is_numeric($value)) {
            // Add .0 for float/double if integer
            if (($fbeType === 'float' || $fbeType === 'double') && !str_contains($value, '.')) {
                return $value . '.0';
            }
            return $value;
        }

        // Handle enum/flag values (e.g., OrderSide.buy)
        if (str_contains($value, '.')) {
            return $value;
        }

        // Default: return as-is
        return $value;
    }

    private function resolveBaseClass(string $baseStruct): string
    {
        // Handle cross-package references (e.g., proto.Balance)
        if (str_contains($baseStruct, '.')) {
            $parts = explode('.', $baseStruct);
            return end($parts);  // For now, just use the class name
        }
        return $baseStruct;
    }

    private function generateModel(array $struct, string $outputDir): void
    {
        $name = $struct['name'];
        $fileName = "$outputDir/{$name}Model.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "use FBE\\*;\n\n";
        $code .= "final class {$name}Model\n{\n";
        $code .= "    private \$buffer;\n";
        $code .= "    private int \$offset;\n\n";

        // Field models
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $fieldModelClass = $this->getFieldModelClass($field['fbeType']);
            $code .= "    private {$fieldModelClass} \${$fieldName};\n";
        }

        // Constructor
        $code .= "\n    public function __construct(\$buffer, int \$offset = 0)\n    {\n";
        $code .= "        \$this->buffer = \$buffer;\n";
        $code .= "        \$this->offset = \$offset;\n\n";

        $fieldOffset = 0;
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $fieldModelClass = $this->getFieldModelClass($field['fbeType']);
            $itemModel = $this->getItemModelForCollection($field['fbeType']);
            
            if ($itemModel) {
                $code .= "        \$this->{$fieldName} = new {$fieldModelClass}(\$buffer, \$offset + {$fieldOffset}, {$itemModel});\n";
            } else {
                $code .= "        \$this->{$fieldName} = new {$fieldModelClass}(\$buffer, \$offset + {$fieldOffset});\n";
            }
            
            $fieldOffset += $this->getFieldSize($field['fbeType']);
        }

        $code .= "    }\n\n";

        // Serialize method
        $code .= "    public function serialize({$name} \$obj, \$buffer): int\n    {\n";
        $code .= "        \$offset = 0;\n";
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $code .= "        \$this->{$fieldName}->set(\$obj->{$fieldName});\n";
            $code .= "        \$offset += \$this->{$fieldName}->size() + \$this->{$fieldName}->extra();\n";
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";

        // Deserialize method
        $code .= "    public function deserialize(\$buffer): {$name}\n    {\n";
        $code .= "        \$obj = new {$name}();\n";
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $code .= "        \$obj->{$fieldName} = \$this->{$fieldName}->get();\n";
        }
        $code .= "        return \$obj;\n";
        $code .= "    }\n";

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateFinalModel(array $struct, string $outputDir): void
    {
        $name = $struct['name'];
        $fileName = "$outputDir/{$name}FinalModel.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";
        $code .= "use FBE\\*;\n\n";
        $code .= "final class {$name}FinalModel\n{\n";
        $code .= "    private \$buffer;\n";
        $code .= "    private int \$offset;\n\n";

        // Field models
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $finalModelClass = $this->getFinalModelClass($field['fbeType']);
            $code .= "    private {$finalModelClass} \${$fieldName};\n";
        }

        // Constructor
        $code .= "\n    public function __construct(\$buffer, int \$offset = 0)\n    {\n";
        $code .= "        \$this->buffer = \$buffer;\n";
        $code .= "        \$this->offset = \$offset;\n\n";

        $fieldOffset = 0;
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $finalModelClass = $this->getFinalModelClass($field['fbeType']);
            $itemModel = $this->getItemModelForCollection($field['fbeType']);
            
            if ($itemModel) {
                $code .= "        \$this->{$fieldName} = new {$finalModelClass}(\$buffer, \$offset + {$fieldOffset}, {$itemModel});\n";
            } else {
                $code .= "        \$this->{$fieldName} = new {$finalModelClass}(\$buffer, \$offset + {$fieldOffset});\n";
            }
            
            $fieldOffset += $this->getFinalFieldSize($field['fbeType']);
        }

        $code .= "    }\n\n";

        // Serialize method
        $code .= "    public function serialize({$name} \$obj, \$buffer): int\n    {\n";
        $code .= "        \$offset = 0;\n";
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $code .= "        \$this->{$fieldName}->set(\$obj->{$fieldName});\n";
            $code .= "        \$offset += \$this->{$fieldName}->size();\n";
        }
        $code .= "        return \$offset;\n";
        $code .= "    }\n\n";

        // Deserialize method
        $code .= "    public function deserialize(\$buffer): {$name}\n    {\n";
        $code .= "        \$obj = new {$name}();\n";
        foreach ($struct['fields'] as $field) {
            $fieldName = $field['name'];
            $code .= "        \$obj->{$fieldName} = \$this->{$fieldName}->get();\n";
        }
        $code .= "        return \$obj;\n";
        $code .= "    }\n";

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function getFieldModelClass(string $type): string
    {
        $typeMap = [
            'bool' => 'FieldModelBool',
            'byte' => 'FieldModelByte',
            'char' => 'FieldModelChar',
            'wchar' => 'FieldModelWChar',
            'int8' => 'FieldModelInt8',
            'uint8' => 'FieldModelUInt8',
            'int16' => 'FieldModelInt16',
            'uint16' => 'FieldModelUInt16',
            'int32' => 'FieldModelInt32',
            'uint32' => 'FieldModelUInt32',
            'int64' => 'FieldModelInt64',
            'uint64' => 'FieldModelUInt64',
            'float' => 'FieldModelFloat',
            'double' => 'FieldModelDouble',
            'string' => 'FieldModelString',
            'bytes' => 'FieldModelBytes',
            'decimal' => 'FieldModelDecimal',
            'timestamp' => 'FieldModelTimestamp',
            'uuid' => 'FieldModelUUID',
        ];

        // Handle collections
        if (str_starts_with($type, 'vector<')) {
            return 'FieldModelVector';
        }
        if (str_starts_with($type, 'array<')) {
            return 'FieldModelArray';
        }
        if (str_starts_with($type, 'map<')) {
            return 'FieldModelMap';
        }
        if (str_starts_with($type, 'set<')) {
            return 'FieldModelSet';
        }

        return $typeMap[$type] ?? 'FieldModelInt32';
    }

    private function getFinalModelClass(string $type): string
    {
        $typeMap = [
            'bool' => 'FinalModelBool',
            'byte' => 'FinalModelByte',
            'char' => 'FinalModelChar',
            'wchar' => 'FinalModelWChar',
            'int8' => 'FinalModelInt8',
            'uint8' => 'FinalModelUInt8',
            'int16' => 'FinalModelInt16',
            'uint16' => 'FinalModelUInt16',
            'int32' => 'FinalModelInt32',
            'uint32' => 'FinalModelUInt32',
            'int64' => 'FinalModelInt64',
            'uint64' => 'FinalModelUInt64',
            'float' => 'FinalModelFloat',
            'double' => 'FinalModelDouble',
            'string' => 'FinalModelString',
            'bytes' => 'FinalModelBytes',
            'decimal' => 'FinalModelDecimal',
            'timestamp' => 'FinalModelTimestamp',
            'uuid' => 'FinalModelUUID',
        ];

        // Handle collections
        if (str_starts_with($type, 'vector<')) {
            return 'FinalModelVector';
        }
        if (str_starts_with($type, 'array<')) {
            return 'FinalModelArray';
        }
        if (str_starts_with($type, 'map<')) {
            return 'FinalModelMap';
        }
        if (str_starts_with($type, 'set<')) {
            return 'FinalModelSet';
        }

        return $typeMap[$type] ?? 'FinalModelInt32';
    }

    private function getItemModelForCollection(string $type): ?string
    {
        // Extract item type from collection
        if (preg_match('/(vector|array|set)<(.+)>/', $type, $match)) {
            $itemType = trim($match[2]);
            return "new " . $this->getFieldModelClass($itemType) . "(\$buffer, 0)";
        }
        return null;
    }

    private function getFieldSize(string $type): int
    {
        // FieldModel: primitives inline, complex pointer-based (4 bytes)
        $sizes = [
            'bool' => 1,
            'byte' => 1,
            'char' => 1,
            'wchar' => 2,
            'int8' => 1,
            'uint8' => 1,
            'int16' => 2,
            'uint16' => 2,
            'int32' => 4,
            'uint32' => 4,
            'int64' => 8,
            'uint64' => 8,
            'float' => 4,
            'double' => 8,
            'string' => 4, // Pointer
            'bytes' => 4,
            'decimal' => 16,
            'timestamp' => 8,
            'uuid' => 16,
        ];

        // Collections are pointer-based
        if (str_starts_with($type, 'vector<') || str_starts_with($type, 'map<') || str_starts_with($type, 'set<')) {
            return 4;
        }

        return $sizes[$type] ?? 4;
    }

    private function getFinalFieldSize(string $type): int
    {
        // FinalModel: inline format, variable size
        // For simplicity, return 4 (will be calculated dynamically)
        return 4;
    }
}

