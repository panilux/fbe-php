#!/usr/bin/env php
<?php
/**
 * Fast Binary Encoding compiler for PHP (V2)
 *
 * Generates modern FieldModel-based code from .fbe schema files
 *
 * Features:
 * - Standard + Final format support
 * - FieldModel pattern
 * - Complex types (UUID, Decimal, Timestamp, Bytes)
 * - Collections (Vector, Optional, Map, Array, List, Set, Hash)
 * - Enums and Flags
 */

declare(strict_types=1);

if ($argc < 3) {
    fwrite(STDERR, "Usage: fbec-v2 <input.fbe> <output_dir> [--format=both|standard|final] [--proto]\n");
    exit(1);
}

$inputFile = $argv[1];
$outputDir = $argv[2];
$format = 'both'; // Default: generate both
$generateProtocol = false;

// Parse options
for ($i = 3; $i < $argc; $i++) {
    if (str_starts_with($argv[$i], '--format=')) {
        $format = substr($argv[$i], 9);
    } elseif ($argv[$i] === '--proto') {
        $generateProtocol = true;
    }
}

try {
    $generator = new FBEGeneratorV2();
    $generator->generate($inputFile, $outputDir, $format, $generateProtocol);
    echo "✓ Code generation successful!\n";
} catch (Exception $e) {
    fwrite(STDERR, "✗ Error: {$e->getMessage()}\n");
    fwrite(STDERR, $e->getTraceAsString() . "\n");
    exit(1);
}

class FBEGeneratorV2
{
    private array $enums = [];
    private array $flags = [];
    private array $structs = [];
    private string $package = '';
    private string $domain = '';

    public function generate(string $inputFile, string $outputDir, string $format, bool $generateProtocol = false): void
    {
        $content = file_get_contents($inputFile);
        if ($content === false) {
            throw new Exception("Failed to read $inputFile");
        }

        if (!is_dir($outputDir) && !mkdir($outputDir, 0755, true)) {
            throw new Exception("Failed to create output directory");
        }

        $this->parse($content);
        $this->generateCode($outputDir, $format);

        // Generate protocol classes if requested
        if ($generateProtocol) {
            $this->generateProtocol($outputDir, $format);
        }

        $stats = sprintf(
            "Generated %d enums, %d flags, %d structs (format: %s)%s\n",
            count($this->enums),
            count($this->flags),
            count($this->structs),
            $format,
            $generateProtocol ? ' + protocol' : ''
        );
        echo $stats;
    }

    private function parse(string $content): void
    {
        $this->parseDomain($content);
        $this->parsePackage($content);
        $this->parseEnums($content);
        $this->parseFlags($content);
        $this->parseStructs($content);
    }

    private function parseDomain(string $content): void
    {
        if (preg_match('/domain\s+([\w.]+)/', $content, $match)) {
            $this->domain = $match[1];
        }
    }

    private function parsePackage(string $content): void
    {
        if (preg_match('/package\s+(\w+)/', $content, $match)) {
            $this->package = $match[1];
        }
    }

    private function parseEnums(string $content): void
    {
        preg_match_all('/enum\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            $index = 0;
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                    $index = (int)$val + 1;
                } else {
                    $key = trim(rtrim($line, ';'));
                    if (!empty($key)) {
                        $values[$key] = (string)$index;
                        $index++;
                    }
                }
            }

            $this->enums[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseFlags(string $content): void
    {
        preg_match_all('/flags\s+(\w+)\s*:\s*(\w+)\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $baseType = $match[2];
            $body = $match[3];

            $values = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                if (str_contains($line, '=')) {
                    [$key, $val] = explode('=', $line, 2);
                    $key = trim($key);
                    $val = trim(rtrim($val, ';'));
                    $values[$key] = $val;
                }
            }

            $this->flags[] = compact('name', 'baseType', 'values');
        }
    }

    private function parseStructs(string $content): void
    {
        // Match: struct Name(id)? (: BaseStruct)? { fields }
        preg_match_all('/struct\s+(\w+)(?:\((\d+)\))?(?:\s*:\s*([\w.]+))?\s*\{([^}]+)\}/s', $content, $matches, PREG_SET_ORDER);

        foreach ($matches as $match) {
            $name = $match[1];
            $id = !empty($match[2]) ? (int)$match[2] : null;
            $baseStruct = !empty($match[3]) ? $match[3] : null;
            $body = $match[4];

            $fields = [];
            foreach (explode("\n", $body) as $line) {
                $line = trim($line);
                if (empty($line) || str_starts_with($line, '//')) {
                    continue;
                }

                // Check for [key] attribute
                $isKey = false;
                if (str_starts_with($line, '[key]')) {
                    $isKey = true;
                    $line = trim(substr($line, 5));
                }

                // Parse: type<generic>? []? name (= defaultValue)?;
                // Supports: vector<int32>, map<string,int32>, optional<string>
                if (preg_match('/(\w+)(?:<([^>]+)>)?(\?)?(\[\])?\s+(\w+)(?:\s*=\s*([^;]+))?/', $line, $fieldMatch)) {
                    $fbeType = $fieldMatch[1];
                    $generic = !empty($fieldMatch[2]) ? $fieldMatch[2] : null;
                    $isOptional = !empty($fieldMatch[3]);
                    $isArray = !empty($fieldMatch[4]);
                    $fieldName = $fieldMatch[5];
                    $defaultValue = isset($fieldMatch[6]) ? trim($fieldMatch[6]) : null;

                    $fields[] = [
                        'fbeType' => $fbeType,
                        'generic' => $generic,
                        'isOptional' => $isOptional,
                        'isArray' => $isArray,
                        'name' => $fieldName,
                        'isKey' => $isKey,
                        'defaultValue' => $defaultValue,
                    ];
                }
            }

            $this->structs[] = compact('name', 'id', 'baseStruct', 'fields');
        }
    }

    private function generateCode(string $outputDir, string $format): void
    {
        // Generate enums and flags (format-independent)
        foreach ($this->enums as $enum) {
            $this->generateEnum($enum, $outputDir);
        }

        foreach ($this->flags as $flags) {
            $this->generateFlags($flags, $outputDir);
        }

        // Generate structs based on format
        foreach ($this->structs as $struct) {
            if ($format === 'both' || $format === 'standard') {
                $this->generateStructModel($struct, $outputDir, 'Standard');
            }
            if ($format === 'both' || $format === 'final') {
                $this->generateStructModel($struct, $outputDir, 'Final');
            }
        }
    }

    private function generateEnum(array $enum, string $outputDir): void
    {
        $name = $enum['name'];
        $fileName = "$outputDir/{$name}.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";

        // Add namespace if package is defined
        if (!empty($this->package)) {
            $namespace = $this->getNamespace();
            $code .= "namespace $namespace;\n\n";
        }

        $code .= "/**\n";
        $code .= " * $name enumeration\n";
        $code .= " * \n";
        $code .= " * Base type: {$enum['baseType']}\n";
        $code .= " */\n";
        $code .= "enum $name: int\n{\n";

        foreach ($enum['values'] as $key => $val) {
            $caseName = ucfirst($key);
            $code .= "    case $caseName = $val;\n";
        }

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateFlags(array $flags, string $outputDir): void
    {
        $name = $flags['name'];
        $fileName = "$outputDir/{$name}.php";

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";

        // Add namespace if package is defined
        if (!empty($this->package)) {
            $namespace = $this->getNamespace();
            $code .= "namespace $namespace;\n\n";
        }

        $code .= "/**\n";
        $code .= " * $name flags\n";
        $code .= " * \n";
        $code .= " * Base type: {$flags['baseType']}\n";
        $code .= " * Usage: {$name}::FLAG1 | {$name}::FLAG2\n";
        $code .= " */\n";
        $code .= "final class $name\n{\n";

        foreach ($flags['values'] as $key => $val) {
            $constName = strtoupper(preg_replace('/([a-z])([A-Z])/', '$1_$2', $key));
            $code .= "    public const $constName = $val;\n";
        }

        // Add helper methods
        $code .= "\n";
        $code .= "    public static function hasFlag(int \$flags, int \$flag): bool\n";
        $code .= "    {\n";
        $code .= "        return (\$flags & \$flag) === \$flag;\n";
        $code .= "    }\n\n";

        $code .= "    public static function setFlag(int \$flags, int \$flag): int\n";
        $code .= "    {\n";
        $code .= "        return \$flags | \$flag;\n";
        $code .= "    }\n\n";

        $code .= "    public static function clearFlag(int \$flags, int \$flag): int\n";
        $code .= "    {\n";
        $code .= "        return \$flags & ~\$flag;\n";
        $code .= "    }\n";

        $code .= "}\n";

        file_put_contents($fileName, $code);
    }

    private function generateStructModel(array $struct, string $outputDir, string $format): void
    {
        $name = $struct['name'];
        $suffix = $format === 'Final' ? 'FinalModel' : 'Model';
        $fileName = "$outputDir/{$name}{$suffix}.php";

        $code = $this->generateStructModelCode($struct, $format);

        file_put_contents($fileName, $code);
    }

    private function generateStructModelCode(array $struct, string $format): string
    {
        $name = $struct['name'];
        $suffix = $format === 'Final' ? 'FinalModel' : 'Model';
        $className = $name . $suffix;

        $code = "<?php\n\ndeclare(strict_types=1);\n\n";

        // Add namespace if package is defined
        if (!empty($this->package)) {
            $namespace = $this->getNamespace();
            $code .= "namespace $namespace;\n\n";
        }

        // Imports
        $code .= "use FBE\\Common\\{ReadBuffer, WriteBuffer, StructModel};\n";
        $code .= "use FBE\\{$format}\\{\n";

        // Collect unique field model types
        $fieldModels = $this->getUniqueFieldModels($struct['fields']);
        $code .= "    " . implode(",\n    ", $fieldModels) . "\n";
        $code .= "};\n\n";

        // Class docblock
        $code .= "/**\n";
        $code .= " * {$name} struct model ($format format)\n";
        if ($struct['id'] !== null) {
            $code .= " * \n";
            $code .= " * ID: {$struct['id']}\n";
        }
        $code .= " */\n";

        // Class declaration
        $extendsClause = '';
        $finalKeyword = 'final ';

        if (!empty($struct['baseStruct'])) {
            $baseClass = $this->resolveBaseClass($struct['baseStruct']) . $suffix;
            $extendsClause = " extends $baseClass";
            $finalKeyword = ''; // Don't use final for inherited structs
        } else {
            $extendsClause = " extends StructModel";
            // Check if this struct is used as a base class
            $isBaseClass = $this->isUsedAsBaseClass($struct['name']);
            $finalKeyword = $isBaseClass ? '' : 'final ';
        }

        $code .= "{$finalKeyword}class $className$extendsClause\n{\n";

        // Generate size() method
        $code .= $this->generateSizeMethod($struct, $format);

        // Generate verify() method
        $code .= $this->generateVerifyMethod($struct, $format);

        // Generate writeHeader() for Standard format
        if ($format === 'Standard') {
            $code .= $this->generateWriteHeaderMethod($struct);
        }

        // Generate field accessor methods
        $offset = 0;
        if ($format === 'Standard') {
            $offset = 4; // Header size
        }

        // Add parent fields offset if inheritance is used
        if (!empty($struct['baseStruct'])) {
            $offset += $this->getParentFieldsSize($struct['baseStruct'], $format);
        }

        $previousFields = [];
        foreach ($struct['fields'] as $field) {
            $code .= $this->generateFieldAccessor($field, $format, $offset, $previousFields);
            $previousFields[] = $field;
            $offset += $this->getFieldSize($field, $format);
        }

        // Generate initializeDefaults() method if any field has default value
        $hasDefaults = false;
        foreach ($struct['fields'] as $field) {
            if (!empty($field['defaultValue'])) {
                $hasDefaults = true;
                break;
            }
        }

        if ($hasDefaults) {
            $code .= $this->generateInitializeDefaultsMethod($struct, $format);
        }

        $code .= "}\n";

        return $code;
    }

    private function getUniqueFieldModels(array $fields): array
    {
        $models = [];

        foreach ($fields as $field) {
            $modelName = $this->getFieldModelName($field);
            if ($modelName && !in_array($modelName, $models)) {
                $models[] = $modelName;
            }
        }

        sort($models);
        return $models;
    }

    private function getFieldModelName(array $field): ?string
    {
        $type = $field['fbeType'];

        // Map FBE types to FieldModel names
        $mapping = [
            'bool' => 'FieldModelBool',
            'byte' => 'FieldModelUInt8',
            'char' => 'FieldModelChar',
            'wchar' => 'FieldModelWChar',
            'int8' => 'FieldModelInt8',
            'int16' => 'FieldModelInt16',
            'int32' => 'FieldModelInt32',
            'int64' => 'FieldModelInt64',
            'uint8' => 'FieldModelUInt8',
            'uint16' => 'FieldModelUInt16',
            'uint32' => 'FieldModelUInt32',
            'uint64' => 'FieldModelUInt64',
            'float' => 'FieldModelFloat',
            'double' => 'FieldModelDouble',
            'string' => 'FieldModelString',
            'bytes' => 'FieldModelBytes',
            'uuid' => 'FieldModelUuid',
            'decimal' => 'FieldModelDecimal',
            'timestamp' => 'FieldModelTimestamp',
        ];

        if (isset($mapping[$type])) {
            return $mapping[$type];
        }

        // Handle collections
        if ($type === 'vector') {
            return 'FieldModelVector';
        }
        if ($type === 'optional') {
            return 'FieldModelOptional';
        }
        if ($type === 'map') {
            return 'FieldModelMap';
        }

        // Check if this is an enum - use its backing type
        foreach ($this->enums as $enum) {
            if ($enum['name'] === $type) {
                // Recursively resolve the backing type
                return $this->getFieldModelName(['fbeType' => $enum['baseType']]);
            }
        }

        // Check if this is flags - use its backing type
        foreach ($this->flags as $flags) {
            if ($flags['name'] === $type) {
                // Recursively resolve the backing type
                return $this->getFieldModelName(['fbeType' => $flags['baseType']]);
            }
        }

        // Handle enums/structs (return null, will be handled specially)
        return null;
    }

    private function generateFieldAccessor(array $field, string $format, int $offset, array $previousFields = []): string
    {
        $fieldName = $field['name'];
        $methodName = lcfirst($fieldName);
        $fieldModelClass = $this->getFieldModelClass($field);

        $code = "\n";
        $code .= "    /**\n";
        $code .= "     * Get {$fieldName} field model\n";
        $code .= "     */\n";
        $code .= "    public function $methodName(): $fieldModelClass\n";
        $code .= "    {\n";

        // Final format with variable-size fields requires runtime offset calculation
        if ($format === 'Final' && $this->hasVariableSizeFieldBefore($previousFields)) {
            $code .= "        // Runtime offset calculation for Final format\n";
            $code .= "        \$currentOffset = \$this->offset";

            $calcOffset = 0;
            foreach ($previousFields as $prevField) {
                $prevMethodName = lcfirst($prevField['name']);
                if ($this->isVariableSize($prevField)) {
                    // Variable-size: must read runtime size
                    $code .= " + $calcOffset;\n";
                    $code .= "        \$size{$prevMethodName} = \$this->buffer->readUInt32(\$currentOffset);\n";
                    $code .= "        \$currentOffset += 4 + \$size{$prevMethodName}";
                    $calcOffset = 0;
                } else {
                    // Fixed-size: add compile-time size
                    $calcOffset += $this->getFieldSize($prevField, $format);
                }
            }
            $code .= " + $calcOffset;\n\n";
            $code .= "        return new $fieldModelClass(\$this->buffer, \$currentOffset";
        } else {
            // Standard format or first field: use compile-time offset
            $code .= "        return new $fieldModelClass(\$this->buffer, \$this->offset + $offset";
        }

        // Add additional parameters for collections
        if ($field['fbeType'] === 'vector' || $field['fbeType'] === 'optional') {
            $elementModel = $this->getElementFieldModel($field);
            $code .= ", $elementModel";
        } elseif ($field['fbeType'] === 'map') {
            [$keyModel, $valueModel] = $this->getKeyValueFieldModels($field);
            $code .= ", $keyModel, $valueModel";
        }

        $code .= ");\n";
        $code .= "    }\n";

        return $code;
    }

    private function isVariableSize(array $field): bool
    {
        $variableTypes = ['string', 'bytes', 'vector', 'optional', 'map', 'list', 'set', 'hash', 'array'];
        return in_array($field['fbeType'], $variableTypes);
    }

    private function hasVariableSizeFieldBefore(array $previousFields): bool
    {
        foreach ($previousFields as $field) {
            if ($this->isVariableSize($field)) {
                return true;
            }
        }
        return false;
    }

    private function getFieldModelClass(array $field): string
    {
        $name = $this->getFieldModelName($field);
        if ($name) {
            return $name;
        }

        // For enums/custom types
        return 'FieldModel' . ucfirst($field['fbeType']);
    }

    private function getElementFieldModel(array $field): string
    {
        // For vector<T> or optional<T>
        if (!$field['generic']) {
            return 'null';
        }

        $generic = trim($field['generic']);
        $fieldModelName = $this->getFieldModelName(['fbeType' => $generic]);

        if ($fieldModelName) {
            return "new $fieldModelName(\$this->buffer, 0)";
        }

        return 'null';
    }

    private function getKeyValueFieldModels(array $field): array
    {
        // For map<K,V>
        if (!$field['generic']) {
            return ['null', 'null'];
        }

        $parts = array_map('trim', explode(',', $field['generic']));
        if (count($parts) !== 2) {
            return ['null', 'null'];
        }

        $keyModel = $this->getFieldModelName(['fbeType' => $parts[0]]);
        $valueModel = $this->getFieldModelName(['fbeType' => $parts[1]]);

        $keyCode = $keyModel ? "new $keyModel(\$this->buffer, 0)" : 'null';
        $valueCode = $valueModel ? "new $valueModel(\$this->buffer, 0)" : 'null';

        return [$keyCode, $valueCode];
    }

    private function getFieldSize(array $field, string $format): int
    {
        // Fixed-size primitive types (INLINE in both formats)
        $sizes = [
            'bool' => 1,
            'byte' => 1,
            'int8' => 1,
            'int16' => 2,
            'int32' => 4,
            'int64' => 8,
            'uint8' => 1,
            'uint16' => 2,
            'uint32' => 4,
            'uint64' => 8,
            'float' => 4,
            'double' => 8,
            'uuid' => 16,
            'decimal' => 16,
            'timestamp' => 8,
        ];

        if (isset($sizes[$field['fbeType']])) {
            // Primitive types are INLINE in both Standard and Final
            return $sizes[$field['fbeType']];
        }

        // Variable-size types (string, bytes, vector, optional, map, etc.)
        if ($format === 'Standard') {
            return 4; // Pointer in Standard format
        } else {
            return 4; // Minimum: size prefix in Final format
        }
    }

    private function getNamespace(): string
    {
        // Convert domain.package to namespace
        // e.g., com.example.proto → Com\Example\Proto

        $parts = [];

        if (!empty($this->domain)) {
            $domainParts = explode('.', $this->domain);
            $parts = array_map('ucfirst', $domainParts);
        }

        if (!empty($this->package)) {
            $parts[] = ucfirst($this->package);
        }

        return implode('\\', $parts);
    }

    private function resolveBaseClass(string $baseStruct): string
    {
        // Handle cross-package references (e.g., proto.Balance)
        if (str_contains($baseStruct, '.')) {
            $parts = explode('.', $baseStruct);
            return end($parts);
        }
        return $baseStruct;
    }

    private function isUsedAsBaseClass(string $structName): bool
    {
        // Check if any struct extends this struct
        foreach ($this->structs as $struct) {
            if (!empty($struct['baseStruct'])) {
                $baseClass = $this->resolveBaseClass($struct['baseStruct']);
                if ($baseClass === $structName) {
                    return true;
                }
            }
        }
        return false;
    }

    private function getParentFieldsSize(string $baseStructName, string $format): int
    {
        // Find the parent struct
        $baseStructName = $this->resolveBaseClass($baseStructName);
        $parentStruct = null;

        foreach ($this->structs as $struct) {
            if ($struct['name'] === $baseStructName) {
                $parentStruct = $struct;
                break;
            }
        }

        if ($parentStruct === null) {
            return 0; // Parent not found
        }

        // Calculate total size of parent fields (recursively if parent also has a parent)
        $totalSize = 0;

        // Add grandparent fields size if exists
        if (!empty($parentStruct['baseStruct'])) {
            $totalSize += $this->getParentFieldsSize($parentStruct['baseStruct'], $format);
        }

        // Add parent's own fields
        foreach ($parentStruct['fields'] as $field) {
            $totalSize += $this->getFieldSize($field, $format);
        }

        return $totalSize;
    }

    private function getTotalFieldCount(string $baseStructName): int
    {
        // Find the parent struct
        $baseStructName = $this->resolveBaseClass($baseStructName);
        $parentStruct = null;

        foreach ($this->structs as $struct) {
            if ($struct['name'] === $baseStructName) {
                $parentStruct = $struct;
                break;
            }
        }

        if ($parentStruct === null) {
            return 0; // Parent not found
        }

        // Calculate total field count (recursively if parent also has a parent)
        $totalCount = count($parentStruct['fields']);

        // Add grandparent fields count if exists
        if (!empty($parentStruct['baseStruct'])) {
            $totalCount += $this->getTotalFieldCount($parentStruct['baseStruct']);
        }

        return $totalCount;
    }

    private function generateSizeMethod(array $struct, string $format): string
    {
        $code = "\n";
        $code .= "    /**\n";
        $code .= "     * Get struct size in bytes\n";
        $code .= "     */\n";
        $code .= "    public function size(): int\n";
        $code .= "    {\n";

        if ($format === 'Standard') {
            // Standard format: header + actual field sizes (primitives inline, variables pointer)
            $headerSize = 4;

            // Calculate total size of own fields
            $fieldsSize = 0;
            foreach ($struct['fields'] as $field) {
                $fieldsSize += $this->getFieldSize($field, 'Standard');
            }

            // Add parent fields size if inheritance is used
            if (!empty($struct['baseStruct'])) {
                $fieldsSize += $this->getParentFieldsSize($struct['baseStruct'], 'Standard');
            }

            $totalSize = $headerSize + $fieldsSize;
            $code .= "        return $totalSize; // Header + fields\n";
        } else {
            // Final format: sum of minimum field sizes
            $code .= "        return " . $this->calculateMinimumSize($struct['fields']) . ";\n";
        }

        $code .= "    }\n";

        return $code;
    }

    private function generateVerifyMethod(array $struct, string $format): string
    {
        $code = "\n";
        $code .= "    /**\n";
        $code .= "     * Verify struct is valid\n";
        $code .= "     */\n";
        $code .= "    public function verify(): bool\n";
        $code .= "    {\n";

        if ($format === 'Standard') {
            $code .= "        if (!(\$this->buffer instanceof \\FBE\\Common\\ReadBuffer)) {\n";
            $code .= "            return false;\n";
            $code .= "        }\n\n";
            $code .= "        \$structSize = \$this->buffer->readUInt32(\$this->offset);\n";
            $code .= "        return \$structSize >= \$this->size();\n";
        } else {
            // Final format: no header, always valid
            $code .= "        return true; // Final format has no header\n";
        }

        $code .= "    }\n";

        return $code;
    }

    private function generateWriteHeaderMethod(array $struct): string
    {
        $code = "\n";
        $code .= "    /**\n";
        $code .= "     * Write struct header (Standard format)\n";
        $code .= "     */\n";
        $code .= "    public function writeHeader(): void\n";
        $code .= "    {\n";
        $code .= "        if (!(\$this->buffer instanceof \\FBE\\Common\\WriteBuffer)) {\n";
        $code .= "            throw new \\RuntimeException('Cannot write to ReadBuffer');\n";
        $code .= "        }\n\n";
        $code .= "        \$this->buffer->writeUInt32(\$this->offset, \$this->size());\n";
        $code .= "    }\n";

        return $code;
    }

    private function generateInitializeDefaultsMethod(array $struct, string $format): string
    {
        $code = "\n";
        $code .= "    /**\n";
        $code .= "     * Initialize fields with default values\n";
        $code .= "     */\n";
        $code .= "    public function initializeDefaults(): void\n";
        $code .= "    {\n";
        $code .= "        if (!(\$this->buffer instanceof \\FBE\\Common\\WriteBuffer)) {\n";
        $code .= "            throw new \\RuntimeException('Cannot initialize defaults on ReadBuffer');\n";
        $code .= "        }\n\n";

        foreach ($struct['fields'] as $field) {
            if (!empty($field['defaultValue'])) {
                $fieldName = lcfirst($field['name']);
                $defaultValue = $field['defaultValue'];

                // Convert default value to PHP syntax
                $phpValue = $this->convertDefaultValueToPhp($defaultValue, $field['fbeType']);

                $code .= "        \$this->{$fieldName}()->set($phpValue);\n";
            }
        }

        $code .= "    }\n";

        return $code;
    }

    private function convertDefaultValueToPhp(string $value, string $type): string
    {
        // Remove quotes if string literal
        if (($value[0] ?? '') === '"' && substr($value, -1) === '"') {
            return $value; // Keep quotes for strings
        }

        // Boolean
        if ($value === 'true' || $value === 'false') {
            return $value;
        }

        // Numeric
        if (is_numeric($value)) {
            return $value;
        }

        // Default: treat as string
        return "\"$value\"";
    }

    private function calculateMinimumSize(array $fields): int
    {
        $size = 0;

        foreach ($fields as $field) {
            $fbeType = $field['fbeType'];

            // Fixed-size types
            $fixedSizes = [
                'bool' => 1,
                'byte' => 1,
                'char' => 1,
                'wchar' => 4,
                'int8' => 1,
                'int16' => 2,
                'int32' => 4,
                'int64' => 8,
                'uint8' => 1,
                'uint16' => 2,
                'uint32' => 4,
                'uint64' => 8,
                'float' => 4,
                'double' => 8,
                'uuid' => 16,
                'decimal' => 16,
                'timestamp' => 8,
            ];

            if (isset($fixedSizes[$fbeType])) {
                $size += $fixedSizes[$fbeType];
            } else {
                // Variable-size types (string, bytes, collections) - minimum 4 bytes for size prefix
                $size += 4;
            }
        }

        return $size;
    }

    /**
     * Generate protocol classes (Sender and Receiver)
     */
    private function generateProtocol(string $outputDir, string $format): void
    {
        // Determine which format to use for protocol
        $protocolFormat = $format === 'both' ? 'final' : $format;
        $suffix = ($protocolFormat === 'final') ? 'FinalModel' : 'Model';

        // Generate Sender
        $this->generateSender($outputDir, $protocolFormat, $suffix);

        // Generate Receiver
        $this->generateReceiver($outputDir, $protocolFormat, $suffix);
    }

    /**
     * Generate Sender class
     */
    private function generateSender(string $outputDir, string $format, string $suffix): void
    {
        $namespace = $this->getNamespace();
        $className = $namespace ? (explode('\\', $namespace)[count(explode('\\', $namespace)) - 1]) : 'Proto';
        $senderClass = $className . 'Sender';

        $code = "<?php\n\ndeclare(strict_types=1);";

        if ($namespace) {
            $code .= "\n\nnamespace $namespace;";
        }

        $code .= "\n\nuse FBE\\Proto\\Sender;\n\n";

        $code .= "/**\n";
        $code .= " * Protocol Sender for $className\n";
        $code .= " * \n";
        $code .= " * Sends messages over network/transport.\n";
        $code .= " * Override onSend() to implement actual transmission.\n";
        $code .= " */\n";
        $code .= "abstract class $senderClass extends Sender\n{\n";

        // Generate send methods for each struct
        foreach ($this->structs as $struct) {
            $name = $struct['name'];
            $typeId = $struct['id'] ?? 0;
            $modelClass = $name . $suffix;

            $code .= "\n";
            $code .= "    /**\n";
            $code .= "     * Send $name message\n";
            $code .= "     * \n";
            $code .= "     * @param $modelClass \$model\n";
            $code .= "     * @return int Bytes sent\n";
            $code .= "     */\n";
            $code .= "    public function send$name($modelClass \$model): int\n";
            $code .= "    {\n";
            $code .= "        return \$this->send(\$model, $typeId);\n";
            $code .= "    }\n";
        }

        $code .= "}\n";

        file_put_contents("$outputDir/$senderClass.php", $code);
    }

    /**
     * Generate Receiver class
     */
    private function generateReceiver(string $outputDir, string $format, string $suffix): void
    {
        $namespace = $this->getNamespace();
        $className = $namespace ? (explode('\\', $namespace)[count(explode('\\', $namespace)) - 1]) : 'Proto';
        $receiverClass = $className . 'Receiver';

        $code = "<?php\n\ndeclare(strict_types=1);";

        if ($namespace) {
            $code .= "\n\nnamespace $namespace;";
        }

        $code .= "\n\nuse FBE\\Proto\\Receiver;\n";
        $code .= "use FBE\\Common\\ReadBuffer;\n\n";

        $code .= "/**\n";
        $code .= " * Protocol Receiver for $className\n";
        $code .= " * \n";
        $code .= " * Receives and dispatches messages.\n";
        $code .= " * Override onReceive*() methods to handle messages.\n";
        $code .= " */\n";
        $code .= "abstract class $receiverClass extends Receiver\n{\n";

        // Generate abstract onReceive methods for each struct
        foreach ($this->structs as $struct) {
            $name = $struct['name'];
            $modelClass = $name . $suffix;

            $code .= "\n";
            $code .= "    /**\n";
            $code .= "     * Handle received $name message\n";
            $code .= "     * \n";
            $code .= "     * @param $modelClass \$model\n";
            $code .= "     */\n";
            $code .= "    abstract protected function onReceive$name($modelClass \$model): void;\n";
        }

        // Generate dispatcher
        $code .= "\n";
        $code .= "    /**\n";
        $code .= "     * Dispatch received message by type ID\n";
        $code .= "     */\n";
        $code .= "    protected function onReceive(int \$typeId, string \$data, int \$size): void\n";
        $code .= "    {\n";
        $code .= "        \$buffer = new ReadBuffer(\$data);\n\n";
        $code .= "        switch (\$typeId) {\n";

        foreach ($this->structs as $struct) {
            $name = $struct['name'];
            $typeId = $struct['id'] ?? 0;
            $modelClass = $name . $suffix;

            $code .= "            case $typeId: // $name\n";
            $code .= "                \$model = new $modelClass(\$buffer, 8); // Skip 8-byte header\n";
            $code .= "                \$this->onReceive$name(\$model);\n";
            $code .= "                break;\n\n";
        }

        $code .= "            default:\n";
        $code .= "                // Unknown message type\n";
        $code .= "                break;\n";
        $code .= "        }\n";
        $code .= "    }\n";

        $code .= "}\n";

        file_put_contents("$outputDir/$receiverClass.php", $code);
    }
}
