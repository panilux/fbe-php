#!/usr/bin/env python3
"""
Cross-Platform Test - Python Side

This script reads FBE binary data generated by PHP and verifies it.

Requirements:
    pip install fbe-python  # or use official FBE Python implementation

Usage:
    php examples/cross_platform_test.php
    python3 examples/cross_platform_test.py
"""

import sys
import struct
import base64
from typing import Optional


class ReadBuffer:
    """Simple FBE ReadBuffer implementation for verification"""

    def __init__(self, data: bytes):
        self.data = data
        self.offset = 0

    def read_int32(self, offset: int) -> int:
        """Read 4-byte signed integer (little-endian)"""
        return struct.unpack('<i', self.data[offset:offset+4])[0]

    def read_int64(self, offset: int) -> int:
        """Read 8-byte signed integer (little-endian)"""
        return struct.unpack('<q', self.data[offset:offset+8])[0]

    def read_uint32(self, offset: int) -> int:
        """Read 4-byte unsigned integer (little-endian)"""
        return struct.unpack('<I', self.data[offset:offset+4])[0]

    def read_float(self, offset: int) -> float:
        """Read 4-byte float"""
        return struct.unpack('<f', self.data[offset:offset+4])[0]

    def read_double(self, offset: int) -> float:
        """Read 8-byte double"""
        return struct.unpack('<d', self.data[offset:offset+8])[0]

    def read_bool(self, offset: int) -> bool:
        """Read 1-byte boolean"""
        return self.data[offset] != 0

    def read_string(self, offset: int) -> tuple[str, int]:
        """Read string inline (Standard format uses inline for simple cases)"""
        # Read size
        size = self.read_uint32(offset)
        if size == 0:
            return ('', 4)

        # Read string data
        string_data = self.data[offset + 4:offset + 4 + size]
        return (string_data.decode('utf-8'), 4 + size)

    def read_bytes(self, offset: int) -> tuple[bytes, int]:
        """Read bytes inline"""
        # Read size
        size = self.read_uint32(offset)
        if size == 0:
            return (b'', 4)

        # Read bytes data
        bytes_data = self.data[offset + 4:offset + 4 + size]
        return (bytes_data, 4 + size)

    def read_uuid(self, offset: int) -> str:
        """Read 16-byte UUID (big-endian)"""
        uuid_bytes = self.data[offset:offset+16]

        # Format as UUID string
        return (
            f"{uuid_bytes[0:4].hex()}-"
            f"{uuid_bytes[4:6].hex()}-"
            f"{uuid_bytes[6:8].hex()}-"
            f"{uuid_bytes[8:10].hex()}-"
            f"{uuid_bytes[10:16].hex()}"
        )

    def read_decimal(self, offset: int) -> str:
        """Read 16-byte decimal (96-bit value + scale)"""
        # This is simplified - real implementation uses GMP
        # For now, just read the bytes
        decimal_bytes = self.data[offset:offset+16]
        return f"<Decimal: {decimal_bytes.hex()}>"

    def read_timestamp(self, offset: int) -> int:
        """Read 8-byte timestamp (nanoseconds)"""
        return self.read_int64(offset)

    def read_vector_int32(self, offset: int) -> tuple[list[int], int]:
        """Read Vector<Int32> inline"""
        # Read count
        count = self.read_uint32(offset)

        # Read elements
        elements = []
        elem_offset = offset + 4
        for i in range(count):
            elements.append(self.read_int32(elem_offset))
            elem_offset += 4

        return (elements, 4 + count * 4)

    def read_vector_string(self, offset: int) -> tuple[list[str], int]:
        """Read Vector<String> inline"""
        # Read count
        count = self.read_uint32(offset)

        # Read strings inline
        elements = []
        str_offset = offset + 4
        for i in range(count):
            str_size = self.read_uint32(str_offset)
            str_data = self.data[str_offset + 4:str_offset + 4 + str_size]
            elements.append(str_data.decode('utf-8'))
            str_offset += 4 + str_size

        return (elements, str_offset - offset)

    def read_optional_int32(self, offset: int) -> tuple[Optional[int], int]:
        """Read Optional<Int32> (Standard format)"""
        has_value = self.read_bool(offset)
        if not has_value:
            return (None, 5)  # 1 byte flag + 4 bytes value

        value = self.read_int32(offset + 1)
        return (value, 5)

    def read_optional_string(self, offset: int) -> tuple[Optional[str], int]:
        """Read Optional<String> inline"""
        has_value = self.read_bool(offset)
        if not has_value:
            return (None, 1)

        string_val, string_size = self.read_string(offset + 1)
        return (string_val, 1 + string_size)


def verify_php_data(file_path: str):
    """Verify FBE data generated by PHP"""

    print("üêç Python Cross-Platform Verification\n")

    # Read binary file
    with open(file_path, 'rb') as f:
        data = f.read()

    print(f"üì¶ Loaded {len(data)} bytes from {file_path}\n")

    buffer = ReadBuffer(data)
    offset = 0

    # Test 1: Primitives
    print("‚úì Reading primitives...")

    int32_val = buffer.read_int32(offset)
    print(f"  Int32: {int32_val} (expected: 42)")
    assert int32_val == 42, f"Int32 mismatch: {int32_val} != 42"
    offset += 4

    int64_val = buffer.read_int64(offset)
    print(f"  Int64: {int64_val} (expected: 9876543210)")
    assert int64_val == 9876543210, f"Int64 mismatch"
    offset += 8

    float_val = buffer.read_float(offset)
    print(f"  Float: {float_val:.5f} (expected: ~3.14159)")
    assert abs(float_val - 3.14159) < 0.001, f"Float mismatch"
    offset += 4

    double_val = buffer.read_double(offset)
    print(f"  Double: {double_val:.15f} (expected: ~2.718281828459045)")
    assert abs(double_val - 2.718281828459045) < 0.000001, f"Double mismatch"
    offset += 8

    bool_val = buffer.read_bool(offset)
    print(f"  Bool: {bool_val} (expected: True)")
    assert bool_val == True, f"Bool mismatch"
    offset += 1

    # Test 2: String
    print("\n‚úì Reading string...")
    string_val, string_size = buffer.read_string(offset)
    print(f"  String: '{string_val}' (expected: 'Hello from PHP FBE!')")
    assert string_val == 'Hello from PHP FBE!', f"String mismatch"
    offset += string_size

    # Test 3: Bytes
    print("\n‚úì Reading bytes...")
    bytes_val, bytes_size = buffer.read_bytes(offset)
    print(f"  Bytes: {bytes_val.hex()} (expected: 00010203 04fffefd)")
    assert bytes_val == b"\x00\x01\x02\x03\x04\xFF\xFE\xFD", f"Bytes mismatch"
    offset += bytes_size

    # Test 4: UUID
    print("\n‚úì Reading UUID...")
    uuid_val = buffer.read_uuid(offset)
    print(f"  UUID: {uuid_val}")
    assert uuid_val == "550e8400-e29b-41d4-a716-446655440000", f"UUID mismatch"
    offset += 16

    # Test 5: Decimal
    print("\n‚úì Reading decimal...")
    decimal_val = buffer.read_decimal(offset)
    print(f"  Decimal: {decimal_val}")
    offset += 16

    # Test 6: Timestamp
    print("\n‚úì Reading timestamp...")
    timestamp_val = buffer.read_timestamp(offset)
    print(f"  Timestamp: {timestamp_val} (expected: 1234567890123456789)")
    assert timestamp_val == 1234567890123456789, f"Timestamp mismatch"
    offset += 8

    # Test 7: Vector<Int32>
    print("\n‚úì Reading vector<int32>...")
    vector_int, vector_int_size = buffer.read_vector_int32(offset)
    print(f"  Vector<Int32>: {vector_int} (expected: [10, 20, 30, 40, 50])")
    assert vector_int == [10, 20, 30, 40, 50], f"Vector<Int32> mismatch"
    offset += vector_int_size

    # Test 8: Vector<String>
    print("\n‚úì Reading vector<string>...")
    vector_str, vector_str_size = buffer.read_vector_string(offset)
    print(f"  Vector<String>: {vector_str} (expected: ['apple', 'banana', 'cherry'])")
    assert vector_str == ['apple', 'banana', 'cherry'], f"Vector<String> mismatch"
    offset += vector_str_size

    # Test 9: Optional<Int32> with value
    print("\n‚úì Reading optional<int32>...")
    optional_int, optional_int_size = buffer.read_optional_int32(offset)
    print(f"  Optional<Int32>: {optional_int} (expected: 999)")
    assert optional_int == 999, f"Optional<Int32> mismatch"
    offset += optional_int_size

    # Test 10: Optional<String> null
    print("\n‚úì Reading optional<string> null...")
    optional_str, optional_str_size = buffer.read_optional_string(offset)
    print(f"  Optional<String>: {optional_str} (expected: None)")
    assert optional_str is None, f"Optional<String> should be None"
    offset += optional_str_size

    print(f"\n‚úÖ All checks passed! Total bytes read: {offset}")
    print("üéâ PHP ‚Üî Python cross-platform compatibility verified!")


if __name__ == '__main__':
    file_path = 'test_cross_platform.fbe'

    try:
        verify_php_data(file_path)
    except FileNotFoundError:
        print(f"‚ùå Error: {file_path} not found")
        print("Run this first: php examples/cross_platform_test.php")
        sys.exit(1)
    except AssertionError as e:
        print(f"\n‚ùå Verification failed: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
